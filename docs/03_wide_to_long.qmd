---
title: "Reshaping Data: Wide to Long and Back"
---

## The Core Functions

The tidyr package (part of tidyverse) provides two essential functions:

- `pivot_longer()` - Convert from wide to long
- `pivot_wider()` - Convert from long to wide

```{r}
#| message: false
library(tidyverse)
```

## pivot_longer(): Wide to Long

This is the transformation you'll use most often. Qualtrics gives you wide data, but repeated measures analyses need long data.

### Basic Syntax

```{r}
#| eval: false
data |>
  pivot_longer(
    cols = <columns to pivot>,      # Which columns contain repeated measures
    names_to = "condition",          # Name for the new grouping column
    values_to = "score"              # Name for the new values column
  )
```

### Example 1: Simple Pre-Post Design

**Starting point (wide):**

```{r}
# Simulated Qualtrics export
wide_prepost <- tibble(
  participant_id = 1:5,
  age = c(22, 25, 21, 28, 24),
  anxiety_pre = c(45, 52, 48, 55, 50),
  anxiety_post = c(38, 42, 40, 45, 41)
)

wide_prepost
```

**Goal:** Convert to long format for paired analysis

```{r}
long_prepost <- wide_prepost |>
  pivot_longer(
    cols = c(anxiety_pre, anxiety_post),  # Columns to pivot
    names_to = "time",                     # New column for time point
    values_to = "anxiety"                  # New column for anxiety scores
  )

long_prepost
```

::: {.callout-note}
Notice that:

- `participant_id` and `age` are preserved (they weren't pivoted)
- Each participant now has 2 rows
- The column names became values in `time`
- The values became a single `anxiety` column
:::

### Example 2: Using Selection Helpers

When you have many columns with a pattern, use selection helpers:

```{r}
# Multiple timepoints
wide_multi <- tibble(
  participant_id = 1:3,
  score_time1 = c(45, 48, 42),
  score_time2 = c(52, 55, 50),
  score_time3 = c(58, 62, 55),
  score_time4 = c(60, 65, 58)
)

# Pivot all columns starting with "score_"
long_multi <- wide_multi |>
  pivot_longer(
    cols = starts_with("score_"),
    names_to = "timepoint",
    values_to = "score"
  )

long_multi
```

Other useful selection helpers:

- `ends_with("_pre")` - Columns ending with "_pre"
- `contains("anxiety")` - Columns containing "anxiety"
- `matches("^q[0-9]+")` - Columns matching a regex pattern
- `num_range("trial", 1:10)` - trial1, trial2, ..., trial10

### Example 3: Cleaning Up the Names

The `time` column still has the prefix. Use `names_prefix` to remove it:

```{r}
long_clean <- wide_multi |>
  pivot_longer(
    cols = starts_with("score_"),
    names_to = "timepoint",
    values_to = "score",
    names_prefix = "score_"  # Remove this prefix from names
  )

long_clean
```

### Example 4: Converting Names to Numbers

Often you want timepoints as numbers, not strings:

```{r}
long_numeric <- wide_multi |>
  pivot_longer(
    cols = starts_with("score_"),
    names_to = "timepoint",
    values_to = "score",
    names_prefix = "score_time",
    names_transform = list(timepoint = as.integer)  # Convert to integer
  )

long_numeric
```

### Example 5: Multiple Variables in Column Names

Sometimes column names encode multiple pieces of information:

```{r}
# Columns encode both measure and timepoint
wide_complex <- tibble(
  participant_id = 1:3,
  anxiety_pre = c(45, 48, 42),
  anxiety_post = c(38, 42, 40),
  depression_pre = c(52, 55, 50),
  depression_post = c(45, 48, 44)
)

# Use names_sep to split the column names
long_complex <- wide_complex |>
  pivot_longer(
    cols = -participant_id,
    names_to = c("measure", "time"),
    names_sep = "_",           # Split on underscore
    values_to = "score"
  )

long_complex
```

### Example 6: Creating Multiple Value Columns

Sometimes you want to keep measures as separate columns:

```{r}
# Use .value to indicate which part becomes column names
wide_multi_measures <- tibble(
  participant_id = 1:3,
  anxiety_pre = c(45, 48, 42),
  anxiety_post = c(38, 42, 40),
  depression_pre = c(52, 55, 50),
  depression_post = c(45, 48, 44)
)

long_multi_measures <- wide_multi_measures |>
  pivot_longer(
    cols = -participant_id,
    names_to = c(".value", "time"),  # .value becomes column names
    names_sep = "_"
  )

long_multi_measures
```

Now `anxiety` and `depression` remain as separate columns, with just `time` as the long variable.

## pivot_wider(): Long to Wide

Less common, but sometimes needed (e.g., for certain base R functions or creating summary tables).

### Basic Syntax

```{r}
#| eval: false
data |>
  pivot_wider(
    names_from = condition,    # Column whose values become new column names
    values_from = score        # Column whose values fill the new columns
  )
```

### Example: Converting Back to Wide

```{r}
# Start with long data
long_data <- tibble(
  participant_id = rep(1:3, each = 2),
  time = rep(c("pre", "post"), 3),
  score = c(45, 38, 48, 42, 42, 40)
)

long_data

# Convert to wide
wide_data <- long_data |>
  pivot_wider(
    names_from = time,
    values_from = score
  )

wide_data
```

### Example: Adding a Prefix to New Column Names

```{r}
wide_prefixed <- long_data |>
  pivot_wider(
    names_from = time,
    values_from = score,
    names_prefix = "score_"  # Add prefix to new columns
  )

wide_prefixed
```

## Real-World Qualtrics Scenarios

### Scenario 1: Repeated Measures with Multiple Trials

You ran an experiment where participants rated 6 different images:

```{r}
# Simulated Qualtrics export
qualtrics_trials <- tibble(
  ResponseId = paste0("R_", 1:4),
  condition = c("control", "treatment", "control", "treatment"),
  image1_rating = c(5, 6, 4, 7),
  image2_rating = c(4, 7, 5, 6),
  image3_rating = c(6, 8, 5, 7),
  image4_rating = c(5, 7, 4, 8),
  image5_rating = c(4, 6, 5, 7),
  image6_rating = c(5, 8, 4, 6)
)

# Convert to long for analysis
trials_long <- qualtrics_trials |>
  pivot_longer(
    cols = contains("image"),
    names_to = "image",
    values_to = "rating",
    names_pattern = "image(\\d+)_rating"  # Extract just the number
  ) |>
  mutate(image = as.integer(image))

trials_long
```

### Scenario 2: Pre-Mid-Post Design with Multiple Outcomes

```{r}
# Qualtrics export with multiple measures at multiple timepoints
qualtrics_multi <- tibble(
  participant_id = 1:3,
  group = c("control", "treatment", "control"),
  wellbeing_t1 = c(45, 48, 42),
  wellbeing_t2 = c(47, 55, 44),
  wellbeing_t3 = c(46, 62, 43),
  stress_t1 = c(60, 58, 65),
  stress_t2 = c(58, 50, 62),
  stress_t3 = c(59, 42, 63)
)

# Method 1: Fully long (each observation is one row)
fully_long <- qualtrics_multi |>
  pivot_longer(
    cols = c(starts_with("wellbeing"), starts_with("stress")),
    names_to = c("measure", "time"),
    names_sep = "_",
    values_to = "score"
  )

head(fully_long, 12)

# Method 2: Keep measures as columns, just time long
time_long <- qualtrics_multi |>
  pivot_longer(
    cols = c(starts_with("wellbeing"), starts_with("stress")),
    names_to = c(".value", "time"),
    names_sep = "_"
  )

time_long
```

### Scenario 3: Loop & Merge Data

Qualtrics Loop & Merge creates columns like `Q1_1`, `Q1_2`, `Q1_3`:

```{r}
# Simulated Loop & Merge export (3 loops, 2 questions each)
loop_merge <- tibble(
  participant_id = 1:3,
  Q1_1 = c(5, 4, 6),  # Question 1, Loop 1
  Q2_1 = c(4, 5, 5),  # Question 2, Loop 1
  Q1_2 = c(6, 5, 7),  # Question 1, Loop 2
  Q2_2 = c(5, 6, 6),  # Question 2, Loop 2
  Q1_3 = c(7, 6, 8),  # Question 1, Loop 3
  Q2_3 = c(6, 7, 7)   # Question 2, Loop 3
)

# Pivot to long format
loop_long <- loop_merge |>
  pivot_longer(
    cols = -participant_id,
    names_to = c("question", "loop"),
    names_pattern = "Q(\\d+)_(\\d+)",  # Regex to capture both numbers
    values_to = "response"
  ) |>
  mutate(
    question = paste0("Q", question),
    loop = as.integer(loop)
  )

loop_long
```

## Common Pitfalls and Solutions

### Pitfall 1: Forgetting ID Columns

```{r}
#| error: true
# WRONG: This will fail or give unexpected results
# pivot_longer(wide_data, cols = everything(), ...)

# CORRECT: Exclude ID columns
wide_data |>
  pivot_longer(
    cols = -participant_id,  # Everything EXCEPT participant_id
    names_to = "time",
    values_to = "score"
  )
```

### Pitfall 2: Non-Unique Rows After Pivoting

If you get unexpected `NA` values or errors, check for duplicate identifiers:

```{r}
# Check for duplicates before pivoting wider
long_data |>
  group_by(participant_id, time) |>
  filter(n() > 1)
```

### Pitfall 3: Mixed Column Types

When pivoting columns with different types:

```{r}
# Problem: age is numeric, condition is character
mixed_wide <- tibble(
  participant_id = 1:3,
  measure_numeric = c(45, 48, 42),
  measure_char = c("high", "low", "medium")
)

# Solution: Pivot separately or convert types first
mixed_long <- mixed_wide |>
  mutate(measure_char = as.character(measure_char)) |>  # Ensure same type

pivot_longer(
    cols = starts_with("measure"),
    names_to = "measure_type",
    values_to = "value",
    values_transform = list(value = as.character)  # Convert all to character
  )
```

## Summary: Choosing the Right Approach

| Situation | Function | Key Arguments |
|-----------|----------|---------------|
| Simple pre/post | `pivot_longer()` | `cols`, `names_to`, `values_to` |
| Remove prefix from names | `pivot_longer()` | + `names_prefix` |
| Multiple timepoints | `pivot_longer()` | + `starts_with()` or pattern |
| Names encode multiple variables | `pivot_longer()` | + `names_sep` or `names_pattern` |
| Keep some measures as columns | `pivot_longer()` | + `.value` in `names_to` |
| Long to wide | `pivot_wider()` | `names_from`, `values_from` |

## Practice Exercise

Try converting this Qualtrics-style data for a repeated measures ANOVA:

```{r}
practice_data <- tibble(
  participant_id = 1:5,
  age = c(22, 25, 21, 28, 24),
  condition = c("A", "A", "B", "B", "A"),
  mood_baseline = c(5, 6, 4, 5, 6),
  mood_week2 = c(5, 7, 4, 6, 7),
  mood_week4 = c(6, 8, 5, 7, 8),
  mood_week6 = c(6, 8, 5, 8, 9)
)
```

**Your task:** Convert to long format with columns: `participant_id`, `age`, `condition`, `week`, `mood`

```{r}
#| code-fold: true
#| code-summary: "Show solution"

solution <- practice_data |>
  pivot_longer(
    cols = starts_with("mood_"),
    names_to = "week",
    values_to = "mood",
    names_prefix = "mood_"
  ) |>
  mutate(
    week = case_match(
      week,
      "baseline" ~ 0,
      "week2" ~ 2,
      "week4" ~ 4,
      "week6" ~ 6
    )
  )

solution
```

## Next Steps

Now that you can reshape your data, the next chapter covers reverse scoring - handling negatively-worded items in your scales before creating composite scores.
